Topics 

1) Inheritance (is – a relationship)
	 is – a relationship
2) Association 
		i) Aggregation ( has – a relationship)  
       ii) composition ( part – of relationship )

3) SDLC ( Software development life cycle ) 
	a) Coupling 
    b) Cohesion 


Association : 
    Association is a relation between two separate classes which establishes through their Objects. Association can be one-to-one, one-to-many, many-to-one, many-to-many. 

Example of Has-a relationship 

Aggregation:  
It is a special form of Association where: soft dependency 
    •  It represents Has-A’s relationship.
    • It is a unidirectional association i.e. a one-way relationship. For example, a department can have students but vice versa is not possible and thus unidirectional in nature.
    • In Aggregation, both entries can survive individually which means ending one entity will not affect the other entity.

Composition 

Composition is a restricted form of Aggregation in which two entities are highly dependent on each other. Hard dependency
    • It represents part-of relationship.
    • In composition, both entities are dependent on each other.
    • When there is a composition between two entities, the composed object cannot exist without the other entity.

Aggregation vs Composition 
1. Dependency: Aggregation implies a relationship where the child can exist independently of the parent. For example, Bank and Employee, delete the Bank and the Employee still exist. whereas Composition implies a relationship where the child cannot exist independent of the parent. Example: Human and heart, heart don’t exist separate to a Human
2. Type of Relationship: Aggregation relation is “has-a” and composition is “part-of” relation.
3. Type of association: Composition is a strong Association whereas Aggregation is a weak Association.

Food for thought 

1) why do programmers use aggregation/composition in Java ?

Ans : Divide and conquer 
















SDLC
   Software development life cycle ( 7 stages )
Stage 1: Project Planning
Stage 2: Gathering Requirements & Analysis
Stage 3: Design
Stage 4: Coding or Implementation
Stage 5: Testing
Stage 6: Deployment
Stage 7: Maintenance

SRS : software requirement specification 
SDD : software Design document  ( Sequence Diagram , Flow Diagram and Use Case diagram )  Ex Visio 

Coupling refers to the degree of interdependence between software modules. High coupling means that modules are closely connected and changes in one module may affect other modules. Low coupling means that modules are independent and changes in one module have little impact on other modules.

Cohesion refers to the degree to which elements within a module work together to fulfill a single, well-defined purpose. High cohesion means that elements are closely related and focused on a single purpose, while low cohesion means that elements are loosely related and serve multiple




Modularization: Modularization is the process of dividing a software system into multiple independent modules where each module works independently. There are many advantages of Modularization in software engineering. Some of these are given below: 
    • Easy to understand the system.
    • System maintenance is easy.
    • A module can be used many times as their requirements. No need to write it again and again.
Refer : S of SOLID design patterns .
Coupling: Coupling is the measure of the degree of interdependence between the modules. A good software will have low coupling. 

Types of Coupling: 
    • Data Coupling: If the dependency between the modules is based on the fact that they communicate by passing only data, then the modules are said to be data coupled. In data coupling, the components are independent of each other and communicate through data. Module communications don’t contain tramp data. Example-customer billing system.
      Best 
    • Stamp Coupling In stamp coupling, the complete data structure is passed from one module to another module. Therefore, it involves tramp data. It may be necessary due to efficiency factors- this choice was made by the insightful designer, not a lazy programmer.
      Not to bad , if communication done through JSON or WSDL
    • Control Coupling: If the modules communicate by passing control information, then they are said to be control coupled. It can be bad if parameters indicate completely different behavior and good if parameters allow factoring and reuse of functionality. Example- sort function that takes comparison function as an argument.
    • External Coupling: In external coupling, the modules depend on other modules, external to the software being developed or to a particular type of hardware. Ex- protocol, external file, device format, etc.
    • Common Coupling: The modules have shared data such as global data structures. The changes in global data mean tracing back to all modules which access that data to evaluate the effect of the change. So it has got disadvantages like difficulty in reusing modules, reduced ability to control data accesses, and reduced maintainability.
      Mostly bad if communicated from module to module , but if there is a federation layer then this works very well
    • Content Coupling: In a content coupling, one module can modify the data of another module, or control flow is passed from one module to the other module. This is the worst form of coupling and should be avoided.
      This should be avoided at any cost , results is data corruption and loss of control .
    • Temporal Coupling: Temporal coupling occurs when two modules depend on the timing or order of events, such as one module needing to execute before another. This type of coupling can result in design issues and difficulties in testing and maintenance.
Race condition 
    • Sequential Coupling: Sequential coupling occurs when the output of one module is used as the input of another module, creating a chain or sequence of dependencies. This type of coupling can be difficult to maintain and modify.
      Not very bad , but results is slow throughput
    • Communicational Coupling: Communicational coupling occurs when two or more modules share a common communication mechanism, such as a shared message queue or database. This type of coupling can lead to performance issues and difficulty in debugging.
      This is a very good form of coupling 
    • Functional Coupling: Functional coupling occurs when two modules depend on each other’s functionality, such as one module calling a function from another module. This type of coupling can result in tightly-coupled code that is difficult to modify and maintain.
      This results is tightly coupled code , barring some scenario of cross cutting code like centralized exception handling 
    • Data-Structured Coupling: Data-structured coupling occurs when two or more modules share a common data structure, such as a database table or data file. This type of coupling can lead to difficulty in maintaining the integrity of the data structure and can result in performance issues.
      Not very bad , when integrating with older systems like mainframes , this is not always avoidable so using a federated layer like hibernate makes life easier 



Cohesion: Cohesion is a measure of the degree to which the elements of the module are functionally related. It is the degree to which all elements directed towards performing a single task are contained in the component. Basically, cohesion is the internal glue that keeps the module together. A good software design will have high cohesion. 
Refer to S of SOLID design patterns .

Types of Cohesion: 
    • Functional Cohesion: Every essential element for a single computation is contained in the component. A functional cohesion performs the task and functions. It is an ideal situation.
      Best 
    • Sequential Cohesion: An element outputs some data that becomes the input for other element, i.e., data flow between the parts. It occurs naturally in functional programming languages.
      Intrinsic to Java , nothing major can be done when not using multithreading .
    • Communicational Cohesion: Two elements operate on the same input data or contribute towards the same output data. Example- update record in the database and send it to the printer.
    • Communicational cohesion occurs when elements or tasks are grouped together in a module based on their interactions with each other, such as a module that handles all interactions with a specific external system or module. This type of cohesion can be found in object-oriented programming languages.
      Extremely useful . MVC works on this model
      Helps is parallel processing 
    • Procedural Cohesion: This type of cohesion occurs when elements or tasks are grouped together in a module based on their sequence of execution, such as a module that performs a set of related procedures in a specific order. Procedural cohesion can be found in structured programming languages.
      Very useful for batch execution 
    • Temporal Cohesion: The elements are related by their timing involved. A module connected with temporal cohesion all the tasks must be executed in the same time span. This cohesion contains the code for initializing all the parts of the system. Lots of different activities occur, all at unit time.
      2 impotent things 1) dirty read 2) if sequencing needs to be done then shedlock like functionality can be used .
    • Logical Cohesion: The elements are logically related and not functionally. Ex- A component reads inputs from tape, disk, and network. All the code for these functions is in the same component. Operations are related, but the functions are significantly different.
      Useful for cross cutting concerns 
    • Coincidental Cohesion: The elements are not related(unrelated). The elements have no conceptual relationship other than location in source code. It is accidental and the worst form of cohesion. Ex- print next line and reverse the characters of a string in a single component. 
    • Layer Cohesion: Layer cohesion occurs when elements or tasks in a module are grouped together based on their level of abstraction or responsibility, such as a module that handles only low-level hardware interactions or a module that handles only high-level business logic. Layer cohesion is commonly used in large-scale software systems to organize code into manageable layers.
      Useful is defining layers service , controller , DAO  etc
      

Advantages of low coupling:
    • Improved maintainability: Low coupling reduces the impact of changes in one module on other modules, making it easier to modify or replace individual components without affecting the entire system.
    • Enhanced modularity: Low coupling allows modules to be developed and tested in isolation, improving the modularity and reusability of code.
    • Better scalability: Low coupling facilitates the addition of new modules and the removal of existing ones, making it easier to scale the system as needed.
Advantages of high cohesion:
    • Improved readability and understandability: High cohesion results in clear, focused modules with a single, well-defined purpose, making it easier for developers to understand the code and make changes.
    • Better error isolation: High cohesion reduces the likelihood that a change in one part of a module will affect other parts, making it easier to
    • isolate and fix errors. Improved reliability: High cohesion leads to modules that are less prone to errors and that function more consistently, 
    • leading to an overall improvement in the reliability of the system.
Disadvantages of high coupling:
    • Increased complexity: High coupling increases the interdependence between modules, making the system more complex and difficult to understand.
    • Reduced flexibility: High coupling makes it more difficult to modify or replace individual components without affecting the entire system.
    • Decreased modularity: High coupling makes it more difficult to develop and test modules in isolation, reducing the modularity and reusability of code.
Disadvantages of low cohesion:
    • Increased code duplication: Low cohesion can lead to the duplication of code, as elements that belong together are split into separate modules.
    • Reduced functionality: Low cohesion can result in modules that lack a clear purpose and contain elements that don’t belong together, reducing their functionality and making them harder to maintain.
    • Difficulty in understanding the module: Low cohesion can make it harder for developers to understand the purpose and behavior of a module, leading to errors and a lack of clarity.








 
